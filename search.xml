<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>react-router：browserRouter与hashRouter</title>
      <link href="/2020/08/30/BrowserRouter/"/>
      <url>/2020/08/30/BrowserRouter/</url>
      
        <content type="html"><![CDATA[<h3 id="react-router【browserRouter与hashRouter】"><a href="#react-router【browserRouter与hashRouter】" class="headerlink" title="react-router【browserRouter与hashRouter】"></a>react-router【browserRouter与hashRouter】</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>构建react项目中，控制路由跳转使用react-router，react-router是以<a href="https://github.com/ReactTraining/history/blob/master/docs/getting-started.md">history</a>为基础的</p><ul><li>A “<strong>browser history</strong>“ is for use in modern web browsers that support the <a href="http://diveintohtml5.info/history.html">HTML5 history API</a> (see <a href="http://caniuse.com/#feat=history">cross-browser compatibility</a>)</li><li>A “<strong>hash history</strong>“ is for use in web browsers where you want to store the location in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash">hash</a> portion of the current URL <u>to avoid sending it to the server when the page reloads</u></li><li>A “<strong>memory history</strong>“ is used as a reference implementation that may be used <u>in non-browser environments</u>, like <a href="https://facebook.github.io/react-native/">React Native</a> or tests</li></ul><p>由于hash值变化不会导致浏览器向服务器发出请求，而且hash改变会触发hashchange事件，浏览器的进后退也能对其进行控制，所以人们在 html5 的 history 出现前，基本都是使用 hash 来实现前端路由的</p><h5 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h5><p>1.浏览器history对象是window对象的一部分，可通过 window.history 属性对其进行访问，其操作的是浏览器的<strong>session history</strong>，即当前回话窗口的history。这是H5提供新的特新，也是以上依赖包的基础；</p><p>2.hash值变化不会导致浏览器向服务器发出请求，且hash改变会触发hashchange事件，浏览器的进后退也能对其进行控制。在 html5 的 history 出现前，基本都是使用 hash 来实现前端路由的；</p><p>3.history依赖包提供了history.listen(myListener)方法，以供使用监听路由变化的逻辑；</p><p>4.关于使用browserRouter时，页面404的解释：没有配置historyApiFallback，即页面没有初始化路由与组件的联系（<a href="https://www.npmjs.com/package/connect-history-api-fallback">connect-history-api-fallback</a>），导致的该路由没有可渲染的组件。可通过webpack配置<code>devServer：&#123;historyApiFallback: true&#125;</code>解决；</p><h4 id="二、browser与hash对比说明"><a href="#二、browser与hash对比说明" class="headerlink" title="二、browser与hash对比说明"></a>二、browser与hash对比说明</h4><h5 id="1-hashRouter"><a href="#1-hashRouter" class="headerlink" title="1.hashRouter"></a>1.hashRouter</h5><p>使用 URL 中的 hash（#）部分去创建路由</p><h5 id="2-browserRouter"><a href="#2-browserRouter" class="headerlink" title="2.browserRouter"></a>2.browserRouter</h5><p>使用浏览器中的 History API 用于处理 URL，因此在browserHistory 模式事，URL 是指向<strong>服务器真实 URL 的资源路径</strong>！</p>]]></content>
      
      
      
        <tags>
            
            <tag> react router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack【dll】</title>
      <link href="/2020/08/30/dll/"/>
      <url>/2020/08/30/dll/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack【dll】"><a href="#webpack【dll】" class="headerlink" title="webpack【dll】"></a>webpack【dll】</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><h5 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1.名词解释"></a>1.名词解释</h5><p>dll（Dynamic Link Library）动态链接库，常见在window系统中，当执行某一个程序时，相应的DLL文件就会被调用。</p><p>将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，但是它增加了构建过程的复杂性。</p><h5 id="2-为什么使用dll"><a href="#2-为什么使用dll" class="headerlink" title="2.为什么使用dll"></a>2.为什么使用dll</h5><ul><li>把复用性较高的第三方模块打包到动态链接库中，在不升级这些库的情况下，动态库不需要重新打包，每次构建只重新打包业务代码；</li><li>亦可将同类资源各自打包第三方，例如react家族、lodash工具库等；一定范围增加文件个数，减少体积，浏览器并发有利于加载时间。</li></ul><h5 id="3-如何使用dll"><a href="#3-如何使用dll" class="headerlink" title="3.如何使用dll"></a>3.如何使用dll</h5><p>使用<code>DLLPlugin</code> 和 <code>DLLReferencePlugin</code> 实现了拆分 bundles，同时还大大提升了构建的速度；使用 <code>AddAssetHtmlPlugin</code>插件将打包后的 dll bundles插入到页面中；</p><p>Github webpack给出了具体的demo和讲解，<a href="https://github.com/webpack/webpack/tree/master/examples/dll-user">戳</a></p><h6 id="3-1-DLLPlugin"><a href="#3-1-DLLPlugin" class="headerlink" title="3.1 DLLPlugin"></a>3.1 DLLPlugin</h6><p>新建webpack.dll.js配置文件，plugin参数配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LIBRARY = <span class="string">&#x27;[name]_[hash]&#x27;</span></span><br><span class="line">output: &#123;</span><br><span class="line">        filename: <span class="string">`<span class="subst">$&#123;LIBRARY&#125;</span>.dll.js`</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        library: LIBRARY,</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            <span class="comment">// manifest json 文件的绝对路径 (输出文件)</span></span><br><span class="line">            path: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;[name]-manifest.json&#x27;</span>),</span><br><span class="line">            <span class="comment">// 暴露出的 DLL 的函数名</span></span><br><span class="line">            name: LIBRARY,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行产出</p><ul><li><p>*.dll.js：文件里是使用数组保存的模块，索引值就作为id；</p></li><li><p>*.manifest.json：文件里，是用来描述对应的dll文件里保存的模块；</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;vendors_b5543b7c65236c1de403&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;./node_modules/@redux-saga/core/dist/io-6de156f3.js&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;buildMeta&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;exportsType&quot;</span>: <span class="string">&quot;namespace&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;providedExports&quot;</span>: []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="3-2-DLLReferencePlugin"><a href="#3-2-DLLReferencePlugin" class="headerlink" title="3.2 DLLReferencePlugin"></a>3.2 DLLReferencePlugin</h6><p>在webpack.common.js配置文件中，添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">       context: __dirname,</span><br><span class="line">       <span class="comment">// eslint-disable-next-line global-require</span></span><br><span class="line">       manifest: <span class="built_in">require</span>(<span class="string">&#x27;./dist/vendors-manifest.json&#x27;</span>),</span><br><span class="line">&#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DllReferencePlugin去 manifest.json 文件读取 name 字段的值，把值的内容作为在从全局变量中获取动态链接库中内容时的全局变量名；因此，在 webpack.dll.js中，DllPlugin 中的 name 参数必须和 output.library 中保持一致。</p><h6 id="3-3-AddAssetHtmlPlugin"><a href="#3-3-AddAssetHtmlPlugin" class="headerlink" title="3.3 AddAssetHtmlPlugin"></a>3.3 AddAssetHtmlPlugin</h6><p>讲打包后的dll插入到入口html中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AddAssetHtmlPlugin(&#123;</span><br><span class="line">            filepath: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;*.dll.js&#x27;</span>),</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS【好文链接】</title>
      <link href="/2020/08/30/good-blog-url/"/>
      <url>/2020/08/30/good-blog-url/</url>
      
        <content type="html"><![CDATA[<h5 id="1、由throw-new-Error-引发的探讨"><a href="#1、由throw-new-Error-引发的探讨" class="headerlink" title="1、由throw new Error() 引发的探讨"></a>1、<a href="https://segmentfault.com/a/1190000010779044">由throw new Error() 引发的探讨</a></h5>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack【plugin-introduce】</title>
      <link href="/2020/08/30/plugin-introduce/"/>
      <url>/2020/08/30/plugin-introduce/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack【plugin-introduce】"><a href="#webpack【plugin-introduce】" class="headerlink" title="webpack【plugin-introduce】"></a>webpack【plugin-introduce】</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>一句话概括plugin的使用场景和作用</p><h5 id="二、Summary"><a href="#二、Summary" class="headerlink" title="二、Summary"></a>二、Summary</h5><p>【<a href="https://www.npmjs.com/package/mini-css-extract-plugin#extracting-css-based-on-entry">mini-css-extract-plugin</a>】：将CSS提取到单独的文件中。它为每个包含CSS的JS文件创建一个CSS文件。它支持CSS和SourceMap的按需加载。</p><p>【<a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin">optimize-css-assets-webpack-plugin</a>】：在Webpack构建期间搜索CSS资产，并优化\最小化CSS（默认情况下，它使用<a href="http://github.com/ben-eb/cssnano">cssnano，</a>但可以指定自定义CSS处理器）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack【可替换模板字符串[name]/[id]/...等变量名释义】</title>
      <link href="/2020/08/29/webpack-temp-string/"/>
      <url>/2020/08/29/webpack-temp-string/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack【可替换模板字符串】"><a href="#webpack【可替换模板字符串】" class="headerlink" title="webpack【可替换模板字符串】"></a>webpack【<strong>可替换模板字符串</strong>】</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>在webpack中，常遇到[name]/[hash]/[id]等占位符，这些占位符多是用来解决<strong>多个入口起点</strong>(entry point)、<strong>代码拆分</strong>(code splitting)或各种插件(plugin)创建<strong>多个 bundle</strong>时的名称或者lib。</p><p>webpack中通过内置的<a href="https://github.com/webpack/webpack/blob/master/lib/TemplatedPathPlugin.js">TemplatedPathPlugin</a>实现了占位符的替换处理工作。</p><h4 id="二、名词解析"><a href="#二、名词解析" class="headerlink" title="二、名词解析"></a>二、名词解析</h4><h5 id="1-name"><a href="#1-name" class="headerlink" title="1.[name]"></a>1.[name]</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123; <span class="attr">index</span>: <span class="string">&quot;./index.js&quot;</span> &#125;,</span><br><span class="line">    output: &#123; <span class="attr">filename</span>: <span class="string">&quot;[name].bundle.js&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[name]一般指的是entry入口定义的输入文件key值，例如此处为index。</p><p>多个入口key分别对应各自的[name]。</p><h5 id="2-id"><a href="#2-id" class="headerlink" title="2.[id]"></a>2.[id]</h5><p>模块标识符(module identifier)。</p><p>id一般用于动态加载模块时，一次构建后，动态加载模块生成的id 。</p><h5 id="3-hash"><a href="#3-hash" class="headerlink" title="3.[hash]"></a>3.[hash]</h5><p>模块标识符(module identifier)的 hash。</p><p>hash是有webpack是一次构建打包生成的hash。</p><h5 id="4-chunkhash"><a href="#4-chunkhash" class="headerlink" title="4.[chunkhash]"></a>4.[chunkhash]</h5><p>根据入口的每一个chunk的内容，生成独有的一份hash。webpack以js为入口，每一个入口通过配置合理的插件可以差分多个文件，例如剥离CSS等，但这些资源文件都归属一个chunk。</p><p>一旦chunk内容发生（可以理解为入口文件未做剥离前的文件构成发生改变），该chunk的hash就会发生变化。</p><h5 id="5-contenthash"><a href="#5-contenthash" class="headerlink" title="5.[contenthash]"></a>5.[contenthash]</h5><p>文件内容 hash，<strong>每个资源</strong>生成的 hash 都是不同的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
